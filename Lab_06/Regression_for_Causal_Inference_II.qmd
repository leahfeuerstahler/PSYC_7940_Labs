---
title: "Lab 6: Regression for Causal Inference II"
date: February 25, 2026
---

## Overview

-   Thinking generatively to simulate data

-   Missing data

Packages for today (install if needed):

```{r}
library(tidyverse)
library(brms)
library(mice)
```


## Thinking Generatively

One benefit of learning about DAGs and causal inference is that it enables us to think **generatively**

- What are the pathways by which data are **generated**?


Benefits of thinking generatively:

- Enables us to better understand and interpret output

- Allows us to **test** our models with **simulated data** that meets our expectations


## Simulation

The biggest advantage of using simulated data is that we already know the **truth**. By comparing the estimated model with the **truth**, we have a powerful tool to help us understand anything that may go wrong with our model.

Let us consider the following model:

```{r echo = FALSE}
library(dagitty)
dag_ea <- dagitty("dag{socmed -> support -> wb <- sex}")
plot(dag_ea)
```

## Simulation

This model implies:

* Well-being is directly affected by sex and support

* Support is directly affected by social media use

::: {.callout-note}

You may hypothesize that there is a more complex relationship between sex and support and/or social media. For instance, if you hypothesize that social support affects well-being differently for different sexes, you may consider moderation/interaction models. Although we don't cover moderation explicitly in this class, you read about it in Ch. 8 of the *Rethinking* textbook.

:::


## Simulation

In our DAG, both `sex` and `soc_med` are unaffected by other variables in our model, so let's start by generating these values.

* Let's generate 100 values

* `sex` has 3 levels: let's assume 45% female, 45% male, and 10% other

* `soc_med` is continuous: let's generate from a standard normal distribution

* Other choices are possible, too!

```{r}
set.seed(235)

N <- 100

sex <- factor(sample(x = c("female", "male", "other"), size = N,
                     replace = TRUE, prob = c(.45, .45, .10)))

soc_med <- rnorm(N)
```


## Simulation

Next, `support` is caused by `soc_med`. Let's assume that this is a positive relationship. One way to generate data based on this causal relationship is to have `soc_med` values determine the mean of the generating normal distribution:

```{r}
support <- rnorm(N, mean = soc_med)
```


## Simulation

Finally, we generate values of `wb` that is affected by *both* `support` and `sex`. The following generates data assuming that well-being for males > females > other

```{r}
sexeffect <- case_when(sex == "male" ~ 1,
                       sex == "female" ~ 0.5,
                       sex == "other" ~ -0.5)

wb <- rnorm(N, mean = support + sexeffect)
```

## Simulation

Combine into a dataset:

```{r}
sim_data <- tibble(sex, soc_med, support, wb)
```


```{r}
head(sim_data)
```

## Simulation

Inspect the data:

```{r}
GGally::ggpairs(sim_data)
```



## Simulation

Rescale our variables like we did in the previous lab:

```{r}
sim_data <- sim_data %>%
  mutate(soc_med = (soc_med - mean(soc_med)) / sd(soc_med),
         support = (support - mean(support)) / sd(support),
         wb = (wb - mean(wb)) / sd(wb))
```


Fit the model using priors from last week:

```{r cache = TRUE}
sim_mod<- bf(wb ~ 0 + sex + support + soc_med) + 
          bf(support ~ 0 + sex + soc_med) + 
          set_rescor(FALSE)

sim_prior <- prior(normal(0, .2), class = "b", coef = "sexfemale", resp = "wb") +
             prior(normal(0, .2), class = "b", coef = "sexmale", resp = "wb") +
             prior(normal(0, .2), class = "b", coef = "sexother", resp = "wb") +
             prior(normal(0, .5), class = "b", coef = "soc_med", resp = "wb") +
             prior(normal(0, .5), class = "b", coef = "support", resp = "wb") +
             prior(exponential(1), class = "sigma", resp = "wb") +
             prior(normal(0, .2), class = "b", coef = "sexfemale", resp = "support") +
             prior(normal(0, .2), class = "b", coef = "sexmale", resp = "support") +
             prior(normal(0, .2), class = "b", coef = "sexother", resp = "support") +
             prior(normal(0, .5), class = "b", coef = "soc_med", resp = "support") +
             prior(exponential(1), class = "sigma", resp = "support")

sim_fit <- brm(formula = sim_mod, data = sim_data, 
               family = gaussian(link = "identity"), prior = sim_prior)
```

## Simulation

Inspect the fitted model results:

* Note which effects have 0 in their CI. Do these patterns match the data generation?

```{r}
#| class-output: "nowrap-code"
print(sim_fit)
```


## Missing Data

To deal with missing data, the default behavior of `brms` is **complete case analysis**, which removes all the rows with any missing values. 

* Even if we decide to conduct complete case analysis, it is best to remove these cases ourselves.

* We still may prefer to omit cases with missing outcome values. 

Two better options available with `brms`:

1. Multiple imputation

2. Simultaneous sampling


## Missing Data

First's let's load in, filter out missing outcome values, and scale the variables. 

* Use of `na.rm = TRUE` means to standardize relative to the available data.

```{r}
#| class-output: "nowrap-code"
d <- read_csv("emerging_adult.csv")
d <- d %>% filter(!is.na(wb)) %>%
      mutate(soc_med = (soc_med - mean(soc_med, na.rm = TRUE)) / sd(soc_med, na.rm = TRUE),
         support = (support - mean(support, na.rm = TRUE)) / sd(support, na.rm = TRUE),
         wb = (wb - mean(wb, na.rm = TRUE)) / sd(wb, na.rm = TRUE))
```


## Missing Data

To create a separate multiple imputation `stan` model, we need to use `mice` function.

```{r warning = FALSE, message=FALSE, cache = TRUE}
d_imp <- mice(d, #dataset we use
              m = 5) #number of data sets to impute
```

## Missing Data

For simplicity, we will fit the multiple regression (not mediation) model.

* Note that we now use `brm_multiple()` intead of `brm()`

If you run this code on your own machine, you may notice that it runs **5 separate models** for the 5 imputed datasets. 

```{r cache = TRUE}
brm_mod <- wb ~ support + soc_med

brm_prior <- prior(normal(0, .1), class = "Intercept") + 
             prior(normal(0, .5), class = "b") + 
             prior(exponential(1), class = "sigma")

mice_mod <- brm_multiple(brm_mod,
                         d_imp,
                         family = gaussian(link = "identity"),
                         prior = brm_prior)
```

## Missing Data

`brm_multiple` automatically pools the multiple imputation results, so the model summary looks familiar.

```{r}
summary(mice_mod)
```

## Missing Data

Another way to conduct multiple imputation is with **simultaneous sampling**. 

* Set up the model as a series of regressions (like we did with mediation).

* For any variable that has an `NA` value, use `variable | mi() ~ ...`. 

* Use `bf()` for each separate equation.

* Can predict missing values based on the prior only (` ~ 1`) or based on other variables in the data (` ~ soc_med`)


This is easiest to see by example:

```{r}
ss_mod <- bf(wb | mi() ~ mi(support) + mi(soc_med)) +
          bf(soc_med | mi() ~ 1) +
          bf(support | mi() ~ mi(soc_med)) +
          set_rescor(FALSE)
```

## Missing Data

Now, each missing predictor value is its own parameter that can be assigned a prior. Because we standardized the data, a standard normal prior may be reasonable.

```{r}
#| class-output: "nowrap-code"
get_prior(ss_mod, d)
```
```{r}
ss_prior <- prior(normal(0, .1), class = "Intercept", resp = "wb") + 
            prior(normal(0, 1), class = "Intercept", resp = "socmed") + 
            prior(normal(0, 1), class = "Intercept", resp = "support") + 
            prior(normal(0, .5), class = "b", resp = "wb") + 
            prior(normal(0, .5), class = "b", resp = "support") + 
            prior(exponential(1), class = "sigma", resp = "wb") + 
            prior(exponential(1), class = "sigma", resp = "socmed") + 
            prior(exponential(1), class = "sigma", resp = "support") 
```



## Missing Data

Fit the model:

```{r message = FALSE, warning = FALSE, cache = TRUE}
ss_fit <- brm(ss_mod,
            family = gaussian(link = "identity"),
            d, prior = ss_prior)
```

## Missing Data

View the fitted model:

```{r}
#| class-output: "nowrap-code"
print(ss_fit)
```

## Activity

Suppose we want to generate data from a partial mediation model where `X` causes `Z` both directly and through a mediator `Y`. This relationship is visualized as follows:

```{r echo = FALSE}
library(dagitty)

dag1 <- dagitty("dag{Y <- X; X -> Z <- Y}")
coordinates(dag1) <- list(x = c(X = 1, Z = 2, Y = 3),
                          y = c(X = 1, Z = 1.1, Y = 1))
plot(dag1)
```

## Activity

1. Based on the model on the previous slide, simulate `X`, `Y` and `Z`:
    
    -   150 sample size.
    -   `X` has an effect on `Y`.
    -   `X` and `Y` have effect on `Z`.
    -   Create a data set named "dat" containing variables above.
    -   Standardize all variables.



2.   Run a multiple regression (not a mediation) model using `brms` with priors $a \sim N(0, .1)$, $b \sim N(0, 1)$, $\sigma \sim Exp(1)$

3. What is your expectation of the result? Does the result meet your expectation?

4.   How would you modify the model to more correctly match the data-generating mechanism?

## Activity

Add ten missing data to the `X` variable using the following code:
```{r eval = FALSE}
set.seed(1678)
X[sample(length(X), 10)] <- NA

# be sure to add this new X to your dataset
```

Use multiple imputation method to run the **correct** model from your perspective.
